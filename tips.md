# 提示

## 3, [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

双指针表示滑动窗口

用**快慢指针**分别维护一个子串的窗口，并把字串中存在的字符，用一个 map 来保存。如果**快**指针指向的字符并不存在于 map 中，那么保存此字符，快指针向右移动，重新计算最大窗口的大小。否则就将**慢**指向的字符从 map 中删除，并向右移动慢指针。如此循环直到快或者慢指针达到字符串末尾。

最坏情况下，快慢指针分别遍历字符串一次，时间复杂度为 O(n)。map 保存所有字符，空间复杂对为 O(n)

在上面的方法中，慢指针一次只能移动一位，不如在遍历字符串的过程中，用 map 来存储已出现的每个字符的 index。这样一来，一旦遇到一个重复的字符，直接就从 map 中读出这个字符上次出现的位置，并把 slow 移动到这个位置。在遍历的同时update 最大窗口的长度。

## 98, [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

1，中序遍历

BST 的中序遍历可以得到一个升序的有序数组。检查数组的有序性就可以验证BST。

时间复杂度是 O(n)，因为要遍历所有n个节点。空间复杂度也是 O(n), 要用数组存储所有n个节点的值来做验证。

2, 迭代

主要是要在迭代函数中传入节点值的上限(max)和下限(min)。max 是用来限制左子树节点中的节点最大值，并在迭代过程中，用当前节点的 val 作为 max 值。反之右子树亦然。

时间复杂度 O(n), 空间复杂度 O(n)

## 146, [实现 LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)

双向链表 + 哈希表

1, 在链表节点结构的定义中，加入 key 字段，方便从哈希表中删除对应节点

2, Get, Put 操作会把节点移到链表尾端。Put 操作会添加节点到尾端，还可能会删除第一个节点。将这些频繁的链表操作实现为单独的方法，可以让 Get 和 Put 的代码更简洁清晰。
